---
Title: "Event Streaming"
github_url: "https://github.com/Macrix/procontel/edit/master/Event%20streaming/README.md"
Weight: 8
Description: >
  Learn how to use the Event Streaming
---

## Introduction

_ProconTEL Event Streaming_ is a set of events which are exposed via _Event Hub_ service to outside world. For example, if endpoint broadcasts a message or completes its activation an event is published by _ProconTEL Event Hub_ service. _Event_ in this context means information about important situation that happened in ProconTel internals. Notice that both - new and old ProconTel SDK are supported. 

## What you can find here?

This documentation contains information about available events and defines scenarios in which events are published and includes instruction how to consume available events. Description of each event contains definition of its' data structure and usage scenario written using BDD approach.

## Table of Contents

1. [Prerequisites](#prerequisites)
2. [How to activate _ProconTEL Event Streaming_](#how-to-activate)
3. [How to consume events](#how-to-consume)
	* [Basics](#how-to-consume-basics)
	* [.NET sample](#how-to-consume-dotnet)
4. [Exposed events](#exposed-events)
	* [Common definitions](#common-definitions)
	* [Traffic events definition](#traffic-events-definition)
		* [Message received](#message-received)
		* [Message enqueued](#message-enqueued)
		* [Message delivered](#message-delivered)
			* [Message delivered event for _Mailslot Telegram Handler_, _TCP Telegram Handler_ and _UDP Telegram Handler_](#message-delivered-standard-endpoints)
		* [Message processed](#message-processed)
			* [Message processed event for _Database Telegram Writer_ and _Telegram Cache_](#message-processed-standard-endpoints1)
			* [Message processed event for _Mailslot Telegram Handler_, _TCP Telegram Handler_ and _UDP Telegram Handler_](#message-processed-standard-endpoints2)
	* [Infrastructure events definition](#infrastructure-events-definition)
	   * [Endpoint activated](#endpoint-activated)
	   * [Endpoint deactivated](#endpoint-deactivated)
	   * [Endpoint connected](#endpoint-connected)
	   * [Endpoint disconnected](#endpoint-disconnected)
	   * [Container activated](#container-activated)
	   * [Container deactivated](#container-deactivated)
	   * [Warning reported](#warning-reported)
	   * [Warning cleared](#warning-cleared)
	   * [Cyclic report](#cyclic-report)
	   * [System failure](#system-failure)
5. [Performance](#performance)

<div id='prerequisites'/>

## Prerequisites
To use _Event Streaming_: 
1. Install _ProconTEL 3.0.20_ or newer.
2. Configure it according to [How to activate ProconTEL Event Streaming](#how-to-activate).

<div id='how-to-activate'/>

## How to activate and configure ProconTEL Event Streaming
Currently Event Streaming is an experimental feature which is turned off by default.  
To activate it, open your **_Server Configuration Manager_** and set property **_General\Enable statistics monitoring mechanism_** to **_True_**.  
Optionally you can change default address used for _Event Streaming_ by editing _General\Event Hub REST API address_. Notice that each ProconTel installation on a server needs its individual Event Hub REST API address.
After that **_ProconTEL Administration_ service must be restarted**.  
Additionally make sure that 'ProconTEL Event Hub' service is running as well.  

<div id='how-to-consume'/>

## How to consume events

<div id='how-to-consume-basics'/>

### Basics

To consume events generated by _Event Hub_ you need to implement your own connector. 
**Event hub publishes events via SignalR**, so at first you need to find SignalR client appropriate for your technology, e.g.: 
* [.NET](https://docs.microsoft.com/en-us/aspnet/core/signalr/dotnet-client)
* [JS](https://docs.microsoft.com/en-us/aspnet/core/signalr/javascript-client)
* [Java](https://docs.microsoft.com/en-us/aspnet/core/signalr/java-client)

Having SignalR client referenced in your custom application, you need to create _HubConnection_ and pass URL to your _Event Hub_, e.g. _'http://{ip}:{port}/events'_.
As a next step you need to subscribe to needed streams/methods: 
* **_trafficEventReceived_**, if you want to receive [traffic events](#traffic-events-definition);
* **_infrastructureEventReceived_**, if you want to receive [infrastructure events](#infrastructure-events-definition).

<div id='how-to-consume-dotnet'/>

### .NET sample
If you are searching for information how to make use of _Event Streaming_ in your .NET application, as a starting point, check out our experimental [sample application](sample/). 

<div id='exposed-events'/>

## Exposed events

<div id='common-definitions'/>

## Common definitions

List of common definitions which are used when defining events.

### Standard endpoints

ProconTEL comes with pre-installed set of endpoints which are called _Standard Endpoints_. In this document only a subset of all pre-installed endpoints is refered to as _Standard Endpoints_ and these are:
- _Database Telegram Writer_,
- _Telegram Cache_,
- _Mailslot Telegram Handler_,
- _TCP Telegram Handler_,
- _UDP Telegram Handler_.

All comes from one library `ProconTel.CommunicationCenter.StandardEndpoints` and uses legacy content processing methods.

### Endpoint Identity

Allows to uniquely identify ProconTEL endpoint. 

```csharp
public class EndpointIdentity
{
    public string ContainerId { get; set; }
    public string EndpointId { get; set; }
}
```

<div id='traffic-events-definition'/>

## Traffic events definition

Below you can find all available events.

<div id='message-received'/>

### Message received
Event `MessageReceived` is published when message is received by channel.

Event content:
```csharp
public string DestinationContainerId { get; set; }
public EndpointIdentity Sender { get; set; }
public string MessageId { get; set; }
public Guid CorrelationId { get; set; }
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public int MessageSize { get; set; }
```

Usage scenarios:

```gherkin
Scenario: message received from channel
Given sender is in channel
 When message is received by channel
 Then event is published
```

```gherkin
Scenario: message received from pool
Given sender is in pool
  And sender has an active and connected avatar in channel
 When message is received by channel
 Then event is published
```

```gherkin
Scenario: message not received from pool 
Given sender is in pool
  And sender has no active or connected avatar in channel
 When message is not received by channel
 Then event is not published
```

<div id='message-enqueued'/>

### Message enqueued
Event `MessageEnqueued` is published when message is added to endpoint internal queue.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string MessageId { get; set; }
public Guid CorrelationId { get; set; }
public EndpointIdentity Queue { get; set; }
```

Usage scenarios:

```gherkin
Scenario: message enqueued by endpoints` queue in channel
Given receiver is an endpoint in channel
 When message enqueued by endpoints` queue 
 Then event is published
```

```gherkin
Scenario: message enqueued by endpoints` queue in pool
Given receiver is an endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is received by pool
 Then event is published
```

```gherkin
Scenario: message enqueued by standard endpoints` queue in channel
Given receiver is a standard endpoint in channel
 When message enqueued by endpoints` queue 
 Then event is published
```

```gherkin
Scenario: message enqueued by standard endpoints` queue in pool
Given receiver is a standard endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is received by pool
 Then event is published
```

<div id='message-delivered'/>

### Message delivered

Event `MessageDelivered` is published when endpoint is about to start processing message.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string MessageId { get; set; }
public Guid CorrelationId { get; set; }
public EndpointIdentity Receiver { get; set; }
```

Usage scenarios:

```gherkin
Scenario: message delivered to endpoint in channel
Given receiver is an endpoint in channel
 When message is received by endpoint 
 Then event is published
```

```gherkin
Scenario: message delivered to endpoint in pool
Given receiver is an endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is received by endpoint
 Then event is published
```

Following scenario applies only to _Database Telegram Writer_ and _Telegram Cache_:

```gherkin
Scenario: message delivered to standard endpoint in channel
Given receiver is a standard endpoint in channel
 When message is received by endpoint 
 Then event is published
```

```gherkin
Scenario: message delivered to standard endpoint in pool
Given receiver is a standard endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is received by endpoint
 Then event is published
```


<div id='message-delivered-standard-endpoints'/>

#### Message delivered event for _Mailslot Telegram Handler_, _TCP Telegram Handler_ and _UDP Telegram Handler_

Event `MessageDelivered` is published when standard endpoint _Mailslot Telegram Handler_, _TCP Telegram Handler_ or _UDP Telegram Handler_ is about to start processing message. In case when many communication partners are defined, event can be published multiple times for the same message.

Usage scenarios:

```gherkin
Scenario: message delivered by Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler in channel
Given receiver is a Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in channel
  And receiver has at least one communication partner available
 When message is received by endpoint
 Then event is published
```

```gherkin
Scenario: message delivered by Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in pool
Given receiver is a Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in pool
  And receiver has an active and connected avatar in channel
  And receiver has at least one communication partner available
 When message is received by endpoint
 Then event is published
```

<div id='message-processed'/>

### Message processed

Event `MessageProcessed` is published when endpoint finished processing message.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string MessageId { get; set; }
public Guid CorrelationId { get; set; }
public EndpointIdentity Receiver { get; set; }
public TimeSpan ProcessingDuration { get; set; }
public bool IsProcessedSuccessfully { get; set; }
```

Usage scenarios:

```gherkin
Scenario: message processed by endpoint in channel
Given receiver is an endpoint in channel
 When message is processed by receiver 
 Then event is published
```

```gherkin
Scenario: message processed by endpoint in pool
Given receiver is an endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is processed by receiver
 Then event is published
```


<div id='message-processed-standard-endpoints1'/>

#### Message processed event for _Database Telegram Writer_ and _Telegram Cache_

Event `MessageProcessed` is published when standard endpoint _Database Telegram Writer_ or _Telegram Cache_ finished processing message.

Usage scenarios:

```gherkin
Scenario: message processed by Telegram Cache or DB Writer in channel
Given receiver is a Telegram Cache or DB Writer endpoint in channel
 When message is processed by receiver 
 Then event is published
```

```gherkin
Scenario: message processed by Telegram Cache or DB Writer endpoint in pool
Given receiver is a Telegram Cache or DB Writer endpoint in pool
  And receiver has an active and connected avatar in channel
 When message is processed by receiver
 Then event is published
```


<div id='message-processed-standard-endpoints2'/>

#### Message processed event for _Mailslot Telegram Handler_, _TCP Telegram Handler_ and _UDP Telegram Handler_

Event `MessageProcessed` is published when standard endpoint _Mailslot Telegram Handler_, _TCP Telegram Handler_ or _UDP Telegram Handler_ sends message to connected communication partner. In case when many communication partners are defined, event can be published multiple times for the same message.

Usage scenarios:

```gherkin
Scenario: message processed by Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler in channel
Given receiver is a Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in channel
  And receiver has at least one communication partner available
 When message is send by receiver to one communication partner
 Then event is published
```

```gherkin
Scenario: message processed by Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in pool
Given receiver is a Mailslot Telegram Handler or TCP Telegram Handler or UDP Telegram Handler endpoint in pool
  And receiver has an active and connected avatar in channel
  And receiver has at least one communication partner available
 When message is send by receiver to one communication partner
 Then event is published
```


<div id='infrastructure-events-definition'/>

## Infrastructure events definition

<div id='endpoint-activated'/>

### Endpoint activated

Event `EndpointActivated` is published when endpoint completed activation.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint activated
Given endpoint in channel or pool
 When endpoint completed activation
 Then event is published
```

<div id='endpoint-deactivated'/>

### Endpoint deactivated

Event `EndpointDeactivated` is published when endpoint completed deactivation.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint deactivated
Given endpoint in channel or pool
 When endpoint completed deactivation
 Then event is published
```

<div id='endpoint-connected'/>

### Endpoint connected

Event `EndpointConnected` is published when endpoint connected to channel.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
public string ConnectedContainerId { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint in channel successfully connected
Given endpoint in channel
 When endpoint completed activation
 Then event is published
```

```gherkin
Scenario: endpoint in pool successfully connected
Given endpoint in pool
  And endpoint has an active and connected avatar in channel
 When endpoint completed activation
 Then event is published
```

```gherkin
Scenario: endpoint in pool not successfully connected
Given endpoint in pool
  And endpoint has active and not connected avatar in channel
 When endpoint completed activation
  And avatar connected with endpoint in pool
 Then event is published
```

```gherkin
Scenario: endpoint in pool and no active or connected avatar
Given endpoint in pool
  And endpoint has no active or connected avatar in channel
 When endpoint completed activation
 Then event is NOT published
```

<div id='endpoint-disconnected'/>

### Endpoint disconnected

Event `EndpointDisconnected` is published when endpoint disconnected from channel.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
public string DisconnectedContainerId { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint in channel disconnected
Given endpoint in channel
 When endpoint completed deactivation
 Then event is published
```

```gherkin
Scenario: endpoint in pool disconnected
Given endpoint in pool
  And endpoint has an active and connected avatar in channel
 When endpoint completed deactivation
 Then event is published
```

```gherkin
Scenario: endpoint in pool active and avatar disconnected
Given endpoint in pool
  And endpoint has active and connected avatar in channel
 When avatar disconnected from endpoint in pool
 Then event is published
```

<div id='container-activated'/>

### Container activated

Event `ContainerActivated` is published when pool or channel is activated.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string ContainerId { get; set; }
```

Usage scenarios:

```gherkin
Scenario: pool or channel is being activated
Given inactive pool or channel
 When container activated
 Then event is published
```

<div id='container-deactivated'/>

### Container deactivated

Event `ContainerDeactivated` is published just before pool or channel is deactivated.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string ContainerId { get; set; }
```

Usage scenarios:

```gherkin
Scenario: pool or channel is being deactivated
Given active pool or channel
 When container is about to deactivate
 Then event is published
```

<div id='warning-reported'/>

### Warning reported

Event `WarningReported` is published when endpoint reported warning.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
public int WarningId { get; set; }
public string WarningMessage { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint reported warning
Given endpoint in channel or pool
 When endpoint reported warning
 Then event is published
```

<div id='warning-cleared'/>

### Warning cleared

Event `WarningCleared` is published when endpoint cleared warning.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public EndpointIdentity Endpoint { get; set; }
public int WarningId { get; set; }
```

Usage scenarios:

```gherkin
Scenario: endpoint cleared warning
Given endpoint in channel or pool
 When endpoint cleared warning
 Then event is published
```

```gherkin
Scenario: endpoint cleared all warnings
Given endpoint in channel or pool
 When endpoint cleared all warnings
 Then event is published for each cleared warning
```

<div id='cyclic-report'/>

### Cyclic report

Event `CyclicReport` is published cyclic every 60 seconds.

Event content:
```csharp
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
public string ContainerId { get; set; }
public long MemoryUsage { get; set; }
public int CpuLoad { get; set; }
public int ThreadsCount { get; set; }
```

Usage scenarios:

```gherkin
Scenario: channel and pool sent cyclic report
Given active channel or pool
 When specified period of time passed 
 Then event is published
```

<div id='system-failure'/>

### System failure

Event `SystemFailure` is published when memory limit for pool or channel is reached.

Event content:
```csharp
public string ContainerId { get; set; }
public string FailureMessage { get; set; }
public DateTimeOffset Timestamp { get; set; } = DateTimeOffset.UtcNow;
```

Usage scenarios:

```gherkin
Scenario: pool or channel reached max memory limit
Given active channel or pool
 And channel or pool has configured max memory limit
 When it is detected that container's memory limit is reached
 Then event is published
```

<div id='performance'/>

## Performance
Using _Event Hub_ obviously affects ProconTel performance. 
Notice when ProconTel message is being transferred from one endpoint to another and Event Hub is on, we publish four additional GRPC messages (MessageReceived, MessageEnqueued, MessageDelivered, MessageProcessed). Writing to GRPC stream costs resources. 
To measure performance we executed the test where we have two isolated endpoints in a single channel. One endpoint is broadcasting a simple message, the other is receiving it. 
When _Event Hub_ is off it took 0,29 milliseconds to transfer single message. When _Event Hub_ is on it took 0,38 ms.

| Case          | Version  | Processing time [ms]  |
| ------------- | -------- | ---------------------:|
| Event Hub Off | 3.0.21.0 |                  0,29 |
| Event Hub On  | 3.0.21.0 |                  0,38 |